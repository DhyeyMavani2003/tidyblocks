<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: expr.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: expr.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict'

const util = require('./util')
const MISSING = util.MISSING

/**
 * Represent an expression as an object. Derived classes must provide `run(row, i)` and `toJSON()`.
 */
class ExprBase {
  constructor (kind) {
    this.kind = kind
  }

  safeValue (value) {
    return isFinite(value) ? value : MISSING
  }
}

// ----------------------------------------------------------------------

/**
 * Generic nullary expression (never instantiated directly).
 */
class ExprNullaryBase extends ExprBase {
  constructor(kind, value) {
    super(kind)
    this.value = value
  }

  equal (other) {
    return (other instanceof ExprNullaryBase) &amp;&amp;
      (this.kind === other.kind) &amp;&amp;
      util.equal(this.value, other.value)
  }

  toJSON () {
    return [Expr.KIND, this.kind, this.value]
  }
}
ExprNullaryBase.OPTIONS = ['logical', 'number', 'string', 'datetime', 'column']

/**
 * Generic unary expressions (never instantiated directly).
 */
class ExprUnary extends ExprBase {
  constructor (kind, arg) {
    util.check(arg instanceof ExprBase,
              `Require expression as child`)
    super(kind)
    this.arg = arg
  }

  equal (other) {
    return (other instanceof ExprUnary) &amp;&amp;
      (this.kind === other.kind) &amp;&amp;
      this.arg.equal(other.arg)
  }

  toJSON () {
    return [Expr.KIND, this.kind, this.arg.toJSON()]
  }
}

/**
 * Binary expressions.
 */
class ExprBinary extends ExprBase {
  constructor (kind, left, right) {
    util.check(left instanceof ExprBase,
              `Require expression as left child`)
    util.check(right instanceof ExprBase,
              `Require expression as right child`)
    super(kind)
    this.left = left
    this.right = right
  }

  equal (other) {
    return (other instanceof ExprBinary) &amp;&amp;
      (this.kind === other.kind) &amp;&amp;
      this.left.equal(other.left) &amp;&amp;
      this.right.equal(other.right)
  }

  toJSON () {
    return [Expr.KIND, this.kind, this.left.toJSON(), this.right.toJSON()]
  }
}

/**
 * Ternary expressions.
 */
class ExprTernaryBase extends ExprBase {
  constructor (kind, left, middle, right) {
    util.check(left instanceof ExprBase,
               `Require expression as left child`)
    util.check(middle instanceof ExprBase,
              `Require expression as middle child`)
    util.check(right instanceof ExprBase,
              `Require expression as right child`)
    super(kind)
    this.left = left
    this.middle = middle
    this.right = right
  }

  equal (other) {
    return (other instanceof ExprTernaryBase) &amp;&amp;
      (this.kind === other.kind) &amp;&amp;
      this.left.equal(other.left) &amp;&amp;
      this.middle.equal(other.middle) &amp;&amp;
      this.right.equal(other.right)
  }

  toJSON () {
    return [Expr.KIND, this.kind, this.left.toJSON(),
            this.middle.toJSON(), this.right.toJSON()]
  }
}

// ----------------------------------------------------------------------

/**
 * Logical value.
 */
class ExprLogical extends ExprNullaryBase {
  constructor (value) {
    util.check((value === MISSING) || (typeof value === 'boolean'),
               `Logical value must be missing or true/false`)
    super(ExprLogical.KIND, value)
  }

  run (row, i) {
    return this.value
  }
}
ExprLogical.KIND = 'logical'

/**
 * Numeric value.
 */
class ExprNumber extends ExprNullaryBase {
  constructor (value) {
    util.check((value === MISSING) || (typeof value === 'number'),
               `Numeric value must be missing or number`)
    super(ExprNumber.KIND, value)
  }

  run (row, i) {
    return this.value
  }
}
ExprNumber.KIND = 'number'

/**
 * Text value.
 */
class ExprString extends ExprNullaryBase {
  constructor (value) {
    util.check((value === MISSING) || (typeof value === 'string'),
               `String value must be missing or string`)
    super(ExprString.KIND, value)
  }

  run (row, i) {
    return this.value
  }
}
ExprString.KIND = 'string'

/**
 * Datetime value.
 */
class ExprDatetime extends ExprNullaryBase {
  constructor (value) {
    util.check((value === MISSING) || (value instanceof Date),
               `Datetime value must be missing or date`)
    super(ExprDatetime.KIND, value)
  }

  run (row, i) {
    return this.value
  }
}
ExprDatetime.KIND = 'datetime'

/**
 * Column value.
 * @param {string} column The column name.
 * @returns The value
 */
class ExprColumn extends ExprNullaryBase {
  constructor (name) {
    util.check(name &amp;&amp; (typeof name === 'string'),
               `Column name must be string`)
    super(ExprColumn.KIND, name)
  }

  run (row, i) {
    util.check(typeof row === 'object',
               `Row must be object`)
    util.check(this.value in row,
               `${this.name} not in row`)
    return row[this.value]
  }
}
ExprColumn.KIND = 'column'

// ----------------------------------------------------------------------

/**
 * Negations.
 */
class ExprNegationBase extends ExprUnary {
  constructor (kind, arg) {
    super(kind, arg)
  }
}
ExprNegationBase.OPTIONS = [['-', 'negate'], 'not']

/**
 * Arithmetic negation.
 * @param {expr} arg How to get the value.
 * @returns The negation.
 */
class ExprNegate extends ExprNegationBase {
  constructor (arg) {
    super(ExprNegate.KIND, arg)
  }

  run (row, i) {
    const value = this.arg.run(row, i)
    util.checkNumber(value,
                     `Require number for ${this.name}`)
    return (value === MISSING) ? MISSING : this.safeValue(-value)
  }
}
ExprNegate.KIND = 'negate'

/**
 * Logical negation.
 * @param {expr} arg How to get the value.
 * @returns The negation.
 */
class ExprNot extends ExprNegationBase {
  constructor (arg) {
    super(ExprNot.KIND, arg)
  }

  run (row, i) {
    const value = this.arg.run(row, i)
    return (value === MISSING) ? MISSING : ((!value) ? true : false)
  }
}
ExprNot.KIND = 'not'

// ----------------------------------------------------------------------

/**
 * Unary type-checking expressions.
 */
class ExprTypecheckBase extends ExprUnary {
  constructor (kind, arg) {
    super(kind, arg)
  }

  typeCheck (row, i, typeName) {
    const value = this.arg.run(row, i)
    return (value === MISSING)
      ? MISSING
      : (typeof value === typeName)
  }
}
ExprTypecheckBase.OPTIONS = ['isLogical', 'isDatetime', 'isMissing',
                             'isNumber', 'isString']

/**
 * Check if a value is Boolean.
 * @param {expr} arg How to get the value.
 * @returns Boolean result.
 */
class ExprIsLogical extends ExprTypecheckBase {
  constructor (arg) {
    super(ExprIsLogical.KIND, arg)
  }

  run (row, i) {
    return this.typeCheck(row, i, 'boolean')
  }
}
ExprIsLogical.KIND = 'isLogical'

/**
 * Check if a value is a datetime.
 * @param {expr} arg How to get the value.
 * @returns Boolean result.
 */
class ExprIsDatetime extends ExprTypecheckBase {
  constructor (arg) {
    super(ExprIsDatetime.KIND, arg)
  }

  run (row, i) {
    const value = this.arg.run(row, i)
    return (value === MISSING) ? MISSING : (value instanceof Date)
  }
}
ExprIsDatetime.KIND = 'isDatetime'

/**
 * Check if a value is missing.
 * @param {expr} arg How to get the value.
 * @returns Boolean result.
 */
class ExprIsMissing extends ExprTypecheckBase {
  constructor (arg) {
    super(ExprIsMissing.KIND, arg)
  }

  run (row, i) {
    const value = this.arg.run(row, i)
    return value === MISSING
  }
}
ExprIsMissing.KIND = 'isMissing'

/**
 * Check if a value is numeric.
 * @param {expr} arg How to get the value.
 * @returns Boolean result.
 */
class ExprIsNumber extends ExprTypecheckBase {
  constructor (arg) {
    super(ExprIsNumber.KIND, arg)
  }

  run (row, i) {
    return this.typeCheck(row, i, 'number')
  }
}
ExprIsNumber.KIND = 'isNumber'

/**
 * Check if a value is a string.
 * @param {expr} arg How to get the value.
 * @returns Boolean result.
 */
class ExprIsString extends ExprTypecheckBase {
  constructor (arg) {
    super(ExprIsString.KIND, arg)
  }

  run (row, i) {
    return this.typeCheck(row, i, 'string')
  }
}
ExprIsString.KIND = 'isString'

// ----------------------------------------------------------------------

/**
 * Unary type conversion expressions.
 */
class ExprConvertBase extends ExprUnary {
  constructor (kind, arg) {
    super(kind, arg)
  }
}
ExprConvertBase.OPTIONS = ['toLogical', 'toDatetime', 'toNumber', 'toString']

/**
 * Convert a value to Boolean.
 * @param {expr} arg How to get the value.
 * @returns Converted value.
 */
class ExprToLogical extends ExprConvertBase {
  constructor (arg) {
    super(ExprToLogical.KIND, arg)
  }

  run (row, i) {
    const value = this.arg.run(row, i)
    return (value === MISSING)
      ? MISSING
      : (value ? true : false)
  }
}
ExprToLogical.KIND = 'toLogical'

/**
 * Convert a value to a datetime.
 * @param {expr} arg How to get the value.
 * @returns Converted value.
 */
class ExprToDatetime extends ExprConvertBase {
  constructor (arg) {
    super(ExprToDatetime.KIND, arg)
  }

  run (row, i) {
    const value = this.arg.run(row, i)
    if (value === MISSING) {
      return MISSING
    }
    let result = new Date(value)
    if ((typeof result === 'object') &amp;&amp;
        (result.toString() === 'Invalid Date')) {
      result = MISSING
    }
    return result
  }
}
ExprToDatetime.KIND = 'toDatetime'

/**
 * Convert a value to a number.
 * @param {expr} arg How to get the value.
 * @returns Converted value.
 */
class ExprToNumber extends ExprConvertBase {
  constructor (arg) {
    super(ExprToNumber.KIND, arg)
  }

  run (row, i) {
    let value = this.arg.run(row, i)
    if (typeof value === 'boolean') {
      value = value ? 1 : 0
    }
    else if (value instanceof Date) {
      value = value.getTime()
    }
    else if (typeof value === 'string') {
      value = parseFloat(value)
      if (Number.isNaN(value)) {
        value = MISSING
      }
    }
    return value
  }
}
ExprToNumber.KIND = 'toNumber'

/**
 * Convert a value to a string.
 * @param {expr} arg How to get the value.
 * @returns Converted value.
 */
class ExprToString extends ExprConvertBase {
  constructor (arg) {
    super(ExprToString.KIND, arg)
  }

  run (row, i) {
    let value = this.arg.run(row, i)
    if (value === MISSING) {
      return MISSING
    }
    if (typeof value !== 'string') {
      value = `${value}`
    }
    return value
  }
}
ExprToString.KIND = 'toString'

// ----------------------------------------------------------------------

/**
 * Unary datetime expressions.
 */
class ExprDatetimeBase extends ExprUnary {
  constructor (kind, arg) {
    super(kind, arg)
  }

  dateValue (row, i, func) {
    const value = this.arg.run(row, i)
    if (value === MISSING) {
      return MISSING
    }
    util.check(value instanceof Date,
               `Require date for ${this.kind}`)
    return func(value)
  }
}
ExprDatetimeBase.OPTIONS = ['toYear', 'toMonth', 'toDay', 'toWeekday',
                            'toHours', 'toMinutes', 'toSeconds']

/**
 * Extract year from date.
 * @param {expr} arg How to get the value.
 * @returns Month.
 */
class ExprToYear extends ExprDatetimeBase {
  constructor (arg) {
    super(ExprToYear.KIND, arg)
  }

  run (row, i) {
    return this.dateValue(row, i, d => d.getFullYear())
  }
}
ExprToYear.KIND = 'toYear'

/**
 * Extract month from date.
 * @param {expr} arg How to get the value.
 * @returns Month.
 */
class ExprToMonth extends ExprDatetimeBase {
  constructor (arg) {
    super(ExprToMonth.KIND, arg)
  }

  run (row, i) {
    return this.dateValue(row, i, d => d.getMonth() + 1)
  }
}
ExprToMonth.KIND = 'toMonth'

/**
 * Extract day of month from date.
 * @param {expr} arg How to get the value.
 * @returns Day.
 */
class ExprToDay extends ExprDatetimeBase {
  constructor (arg) {
    super(ExprToDay.KIND, arg)
  }

  run (row, i) {
    return this.dateValue(row, i, d => d.getDate())
  }
}
ExprToDay.KIND = 'toDay'

/**
 * Extract day of week from date.
 * @param {expr} arg How to get the value.
 * @returns Day.
 */
class ExprToWeekday extends ExprDatetimeBase {
  constructor (arg) {
    super(ExprToWeekday.KIND, arg)
  }

  run (row, i) {
    return this.dateValue(row, i, d => d.getDay())
  }
}
ExprToWeekday.KIND = 'toWeekday'

/**
 * Extract hour from date.
 * @param {expr} arg How to get the value.
 * @returns Hour.
 */
class ExprToHours extends ExprDatetimeBase {
  constructor (arg) {
    super(ExprToHours.KIND, arg)
  }

  run (row, i) {
    return this.dateValue(row, i, d => d.getHours())
  }
}
ExprToHours.KIND = 'toHours'

/**
 * Extract minutes from date.
 * @param {expr} arg How to get the value.
 * @returns Minutes.
 */
class ExprToMinutes extends ExprDatetimeBase {
  constructor (arg) {
    super(ExprToMinutes.KIND, arg)
  }

  run (row, i) {
    return this.dateValue(row, i, d => d.getMinutes())
  }
}
ExprToMinutes.KIND = 'toMinutes'

/**
 * Extract seconds from date.
 * @param {expr} arg How to get the value.
 * @returns Seconds.
 */
class ExprToSeconds extends ExprDatetimeBase {
  constructor (arg) {
    super(ExprToSeconds.KIND, arg)
  }

  run (row, i) { 
    return this.dateValue(row, i, d => d.getSeconds())
  }
}
ExprToSeconds.KIND = 'toSeconds'

// ----------------------------------------------------------------------

/**
 * Binary arithmetic expressions.
 */
class ExprArithmeticBase extends ExprBinary {
  constructor (kind, left, right) {
    super(kind, left, right)
  }

  arithmetic (row, i, func) {
    const left = this.left.run(row, i)
    util.checkNumber(left,
                     `Require number for ${this.kind}`)
    const right = this.right.run(row, i)
    util.checkNumber(right,
                     `Require number for ${this.kind}`)
    return ((left === MISSING) || (right === MISSING))
      ? MISSING
      : this.safeValue(func(left, right))
  }
}
ExprArithmeticBase.OPTIONS = [['+', 'add'], ['-', 'subtract'],
                          ['*', 'multiply'], ['/', 'divide'],
                          ['%', 'remainder'], ['**', 'power']]

/**
 * Addition.
 * @param {expr} left How to get the left value.
 * @param {expr} right How to get the right value.
 * @returns The sum.
 */
class ExprAdd extends ExprArithmeticBase {
  constructor (left, right) {
    super(ExprAdd.KIND, left, right)
  }

  run (row, i) {
    return this.arithmetic(row, i, (left, right) => left + right)
  }
}
ExprAdd.KIND = 'add'

/**
 * Division.
 * @param {expr} left How to get the left value.
 * @param {expr} right How to get the right value.
 * @returns The quotient.
 */
class ExprDivide extends ExprArithmeticBase {
  constructor (left, right) {
    super(ExprDivide.KIND, left, right)
  }

  run (row, i) {
    return this.arithmetic(row, i, (left, right) => left / right)
  }
}
ExprDivide.KIND = 'divide'

/**
 * Multiplication.
 * @param {expr} left How to get the left value.
 * @param {expr} right How to get the right value.
 * @returns The product.
 */
class ExprMultiply extends ExprArithmeticBase {
  constructor (left, right) {
    super(ExprMultiply.KIND, left, right)
  }

  run (row, i) {
    return this.arithmetic(row, i, (left, right) => left * right)
  }
}
ExprMultiply.KIND = 'multiply'

/**
 * Exponentiation.
 * @param {expr} left How to get the left value.
 * @param {expr} right How to get the right value.
 * @returns The power.
 */
class ExprPower extends ExprArithmeticBase {
  constructor (left, right) {
    super(ExprPower.KIND, left, right)
  }

  run (row, i) {
    return this.arithmetic(row, i, (left, right) => left ** right)
  }
}
ExprPower.KIND = 'power'

/**
 * Remainder.
 * @param {expr} left How to get the left value.
 * @param {expr} right How to get the right value.
 * @returns The remainder.
 */
class ExprRemainder extends ExprArithmeticBase {
  constructor (left, right) {
    super(ExprRemainder.KIND, left, right)
  }

  run (row, i) {
    return this.arithmetic(row, i, (left, right) => left % right)
  }
}
ExprRemainder.KIND = 'remainder'

/**
 * Subtraction.
 * @param {expr} left How to get the left value.
 * @param {expr} right How to get the right value.
 * @returns The difference.
 */
class ExprSubtract extends ExprArithmeticBase {
  constructor (left, right) {
    super(ExprSubtract.KIND, left, right)
  }

  run (row, i) {
    return this.arithmetic(row, i, (left, right) => left - right)
  }
}
ExprSubtract.KIND = 'subtract'

// ----------------------------------------------------------------------

/**
 * Binary comparison expressions.
 */
class ExprCompareBase extends ExprBinary {
  constructor (kind, left, right) {
    super(kind, left, right)
  }

  comparison (row, i, func) {
    const left = this.left.run(row, i)
    const right = this.right.run(row, i)
    util.checkTypeEqual(left, right,
                        `Require equal types for ${this.kind}`)
    return ((left === MISSING) || (right === MISSING))
      ? MISSING
      : func(left, right)
  }
}
ExprCompareBase.OPTIONS = [['==', 'equal'], ['!=', 'notEqual'],
                       ['&amp;gt;', 'greater'], ['&amp;gt;=', 'greaterEqual'],
                       ['&amp;lt;=', 'lessEqual'], ['&amp;lt;', 'less']]

/**
 * Equality.
 * @param {expr} left How to get the left value.
 * @param {expr} right How to get the right value.
 * @returns The Boolean result.
 */
class ExprEqual extends ExprCompareBase {
  constructor (left, right) {
    super(ExprEqual.KIND, left, right)
  }

  run (row, i) {
    return this.comparison(row, i, (left, right) => util.equal(left, right))
  }
}
ExprEqual.KIND = 'equal'

/**
 * Strictly greater than.
 * @param {expr} left How to get the left value.
 * @param {expr} right How to get the right value.
 * @returns The Boolean result.
 */
class ExprGreater extends ExprCompareBase {
  constructor (left, right) {
    super(ExprGreater.KIND, left, right)
  }

  run (row, i) {
    return this.comparison(row, i, (left, right) => (left > right))
  }
}
ExprGreater.KIND = 'greater'

/**
 * Greater than or equal.
 * @param {expr} left How to get the left value.
 * @param {expr} right How to get the right value.
 * @returns The Boolean result.
 */
class ExprGreaterEqual extends ExprCompareBase {
  constructor (left, right) {
    super(ExprGreaterEqual.KIND, left, right)
  }

  run (row, i) {
    return this.comparison(row, i, (left, right) => (left >= right))
  }
}
ExprGreaterEqual.KIND = 'greaterEqual'

/**
 * Strictly less than.
 * @param {expr} left How to get the left value.
 * @param {expr} right How to get the right value.
 * @returns The Boolean result.
 */
class ExprLess extends ExprCompareBase {
  constructor (left, right) {
    super(ExprLess.KIND, left, right)
  }

  run (row, i) {
    return this.comparison(row, i, (left, right) => (left &lt; right))
  }
}
ExprLess.KIND = 'less'

/**
 * Less than or equal.
 * @param {expr} left How to get the left value.
 * @param {expr} right How to get the right value.
 * @returns The Boolean result.
 */
class ExprLessEqual extends ExprCompareBase {
  constructor (left, right) {
    super(ExprLessEqual.KIND, left, right)
  }

  run (row, i) {
    return this.comparison(row, i, (left, right) => (left &lt;= right))
  }
}
ExprLessEqual.KIND = 'lessEqual'

/**
 * Inequality.
 * @param {expr} left How to get the left value.
 * @param {expr} right How to get the right value.
 * @returns The Boolean result.
 */
class ExprNotEqual extends ExprCompareBase {
  constructor (left, right) {
    super(ExprNotEqual.KIND, left, right)
  }

  run (row, i) {
    return this.comparison(row, i, (left, right) => (!util.equal(left, right)))
  }
}
ExprNotEqual.KIND = 'notEqual'

// ----------------------------------------------------------------------

/**
 * Binary logical expressions.
 */
class ExprLogicalBase extends ExprBinary {
  constructor (kind, left, right) {
    super(kind, left, right)
  }
}
ExprLogicalBase.OPTIONS = ['and', 'or']

/**
 * Logical conjunction.
 * @param {expr} left How to get the left value.
 * @param {expr} right How to get the right value.
 * @returns The conjunction using short-circuit evaluation.
 */
class ExprAnd extends ExprLogicalBase {
  constructor (left, right) {
    super(ExprAnd.KIND, left, right)
  }

  run (row, i) {
    const left = this.left.run(row, i)
    if (!left) {
      return left
    }
    return this.right.run(row, i)
  }
}
ExprAnd.KIND = 'and'

/**
 * Logical disjunction.
 * @param {expr} left How to get the left value.
 * @param {expr} right How to get the right value.
 * @returns The disjunction using short-circuit evaluation.
 */
class ExprOr extends ExprLogicalBase {
  constructor (left, right) {
    super(ExprOr.KIND, left, right)
  }

  run (row, i) {
    const left = this.left.run(row, i)
    if (left) {
      return left
    }
    return this.right.run(row, i)
  }
}
ExprOr.KIND = 'or'

// ----------------------------------------------------------------------

/**
 * Logical selection.
 * @param {expr} left How to get the left value.
 * @param {expr} middle How to get the middle value.
 * @param {expr} right How to get the right value.
 * @returns The Boolean result.
 */
class ExprIfElse extends ExprTernaryBase {
  constructor (left, middle, right) {
    super(ExprIfElse.KIND, left, middle, right)
  }

  run (row, i) {
    const cond = this.left.run(row, i)
    return (cond === MISSING)
      ? MISSING
      : (cond ? this.middle.run(row, i) : this.right.run(row, i))
  }
}
ExprIfElse.KIND = 'ifElse'

// ----------------------------------------------------------------------

/**
 * Lookup table of everything exported from this file.
 */
const Expr = {
  KIND: '@expr',

  base: ExprBase,
  logical: ExprLogical,
  number: ExprNumber,
  string: ExprString,
  datetime: ExprDatetime,
  column: ExprColumn,
  add: ExprAdd,
  and: ExprAnd,
  divide: ExprDivide,
  equal: ExprEqual,
  greater: ExprGreater,
  greaterEqual: ExprGreaterEqual,
  ifElse: ExprIfElse,
  less: ExprLess,
  lessEqual: ExprLessEqual,
  multiply: ExprMultiply,
  negate: ExprNegate,
  not: ExprNot,
  notEqual: ExprNotEqual,
  or: ExprOr,
  power: ExprPower,
  remainder: ExprRemainder,
  subtract: ExprSubtract,
  isLogical: ExprIsLogical,
  isDatetime: ExprIsDatetime,
  isMissing: ExprIsMissing,
  isNumber: ExprIsNumber,
  isString: ExprIsString,
  toLogical: ExprToLogical,
  toDatetime: ExprToDatetime,
  toNumber: ExprToNumber,
  toString: ExprToString,
  toYear: ExprToYear,
  toMonth: ExprToMonth,
  toDay: ExprToDay,
  toWeekday: ExprToWeekday,
  toHours: ExprToHours,
  toMinutes: ExprToMinutes,
  toSeconds: ExprToSeconds
}

module.exports = {Expr}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BrowserInterface.html">BrowserInterface</a></li><li><a href="DataFrame.html">DataFrame</a></li><li><a href="Environment.html">Environment</a></li><li><a href="ExprAdd.html">ExprAdd</a></li><li><a href="ExprAnd.html">ExprAnd</a></li><li><a href="ExprArithmeticBase.html">ExprArithmeticBase</a></li><li><a href="ExprBase.html">ExprBase</a></li><li><a href="ExprBinary.html">ExprBinary</a></li><li><a href="ExprColumn.html">ExprColumn</a></li><li><a href="ExprCompareBase.html">ExprCompareBase</a></li><li><a href="ExprConvertBase.html">ExprConvertBase</a></li><li><a href="ExprDatetime.html">ExprDatetime</a></li><li><a href="ExprDatetimeBase.html">ExprDatetimeBase</a></li><li><a href="ExprDivide.html">ExprDivide</a></li><li><a href="ExprEqual.html">ExprEqual</a></li><li><a href="ExprGreater.html">ExprGreater</a></li><li><a href="ExprGreaterEqual.html">ExprGreaterEqual</a></li><li><a href="ExprIfElse.html">ExprIfElse</a></li><li><a href="ExprIsDatetime.html">ExprIsDatetime</a></li><li><a href="ExprIsLogical.html">ExprIsLogical</a></li><li><a href="ExprIsMissing.html">ExprIsMissing</a></li><li><a href="ExprIsNumber.html">ExprIsNumber</a></li><li><a href="ExprIsString.html">ExprIsString</a></li><li><a href="ExprLess.html">ExprLess</a></li><li><a href="ExprLessEqual.html">ExprLessEqual</a></li><li><a href="ExprLogical.html">ExprLogical</a></li><li><a href="ExprLogicalBase.html">ExprLogicalBase</a></li><li><a href="ExprMultiply.html">ExprMultiply</a></li><li><a href="ExprNegate.html">ExprNegate</a></li><li><a href="ExprNegationBase.html">ExprNegationBase</a></li><li><a href="ExprNot.html">ExprNot</a></li><li><a href="ExprNotEqual.html">ExprNotEqual</a></li><li><a href="ExprNullaryBase.html">ExprNullaryBase</a></li><li><a href="ExprNumber.html">ExprNumber</a></li><li><a href="ExprOr.html">ExprOr</a></li><li><a href="ExprPower.html">ExprPower</a></li><li><a href="ExprRemainder.html">ExprRemainder</a></li><li><a href="ExprString.html">ExprString</a></li><li><a href="ExprSubtract.html">ExprSubtract</a></li><li><a href="ExprTernaryBase.html">ExprTernaryBase</a></li><li><a href="ExprToDatetime.html">ExprToDatetime</a></li><li><a href="ExprToDay.html">ExprToDay</a></li><li><a href="ExprToHours.html">ExprToHours</a></li><li><a href="ExprToLogical.html">ExprToLogical</a></li><li><a href="ExprToMinutes.html">ExprToMinutes</a></li><li><a href="ExprToMonth.html">ExprToMonth</a></li><li><a href="ExprToNumber.html">ExprToNumber</a></li><li><a href="ExprToSeconds.html">ExprToSeconds</a></li><li><a href="ExprToString.html">ExprToString</a></li><li><a href="ExprToWeekday.html">ExprToWeekday</a></li><li><a href="ExprToYear.html">ExprToYear</a></li><li><a href="ExprTypecheckBase.html">ExprTypecheckBase</a></li><li><a href="ExprUnary.html">ExprUnary</a></li><li><a href="Pipeline.html">Pipeline</a></li><li><a href="Program.html">Program</a></li><li><a href="StageANOVA.html">StageANOVA</a></li><li><a href="StageBar.html">StageBar</a></li><li><a href="StageBase.html">StageBase</a></li><li><a href="StageBox.html">StageBox</a></li><li><a href="StageDot.html">StageDot</a></li><li><a href="StageDrop.html">StageDrop</a></li><li><a href="StageFilter.html">StageFilter</a></li><li><a href="StageGroupBy.html">StageGroupBy</a></li><li><a href="StageHistogram.html">StageHistogram</a></li><li><a href="StageJoin.html">StageJoin</a></li><li><a href="StageKolmogorovSmirnov.html">StageKolmogorovSmirnov</a></li><li><a href="StageKruskalWallis.html">StageKruskalWallis</a></li><li><a href="StageMutate.html">StageMutate</a></li><li><a href="StageNotify.html">StageNotify</a></li><li><a href="StagePlot.html">StagePlot</a></li><li><a href="StageRead.html">StageRead</a></li><li><a href="StageScatter.html">StageScatter</a></li><li><a href="StageSelect.html">StageSelect</a></li><li><a href="StageSort.html">StageSort</a></li><li><a href="StageStats.html">StageStats</a></li><li><a href="StageSummarize.html">StageSummarize</a></li><li><a href="StageTransform.html">StageTransform</a></li><li><a href="StageTTestOneSample.html">StageTTestOneSample</a></li><li><a href="StageTTestPaired.html">StageTTestPaired</a></li><li><a href="StageUngroup.html">StageUngroup</a></li><li><a href="StageUnique.html">StageUnique</a></li><li><a href="StageZTestOneSample.html">StageZTestOneSample</a></li><li><a href="Statistics.html">Statistics</a></li><li><a href="SummarizeBase.html">SummarizeBase</a></li><li><a href="SummarizeCount.html">SummarizeCount</a></li><li><a href="SummarizeMaximum.html">SummarizeMaximum</a></li><li><a href="SummarizeMean.html">SummarizeMean</a></li><li><a href="SummarizeMedian.html">SummarizeMedian</a></li><li><a href="SummarizeMinimum.html">SummarizeMinimum</a></li><li><a href="SummarizeStdDev.html">SummarizeStdDev</a></li><li><a href="SummarizeSum.html">SummarizeSum</a></li><li><a href="SummarizeVariance.html">SummarizeVariance</a></li><li><a href="UserInterface.html">UserInterface</a></li></ul><h3>Global</h3><ul><li><a href="global.html#check">check</a></li><li><a href="global.html#checkNumber">checkNumber</a></li><li><a href="global.html#checkTypeEqual">checkTypeEqual</a></li><li><a href="global.html#csvToTable">csvToTable</a></li><li><a href="global.html#equal">equal</a></li><li><a href="global.html#Expr">Expr</a></li><li><a href="global.html#fail">fail</a></li><li><a href="global.html#MISSING">MISSING</a></li><li><a href="global.html#Stage">Stage</a></li><li><a href="global.html#Summarize">Summarize</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
