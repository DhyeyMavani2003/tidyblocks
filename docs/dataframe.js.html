<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: dataframe.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: dataframe.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict'

const util = require('./util')
const MISSING = util.MISSING
const {Expr} = require('./expr')
const {Summarize} = require('./summarize')

/**
 * Store a dataframe.
 */
class DataFrame {
  /**
   * Construct a new dataframe.
   * @param {Object[]} values The dataframe's values (aliased, not copied).
   * @param {string[]} oldColumns The names of columns (used when making an empty dataframe).
   */
  constructor (values, oldColumns = null) {
    this._checkData(values)
    this.data = values
    this.columns = this._makeColumns(values, oldColumns)
  }

  /**
   * Check if two dataframes are equal (used primarily in testing).
   * @param {Object} other The other dataframe.
   * @returns A Boolean result.
   */
  equal (other) {
    util.check(other instanceof DataFrame,
               `Can only compare dataframes with dataframes`)

    const cols = Array.from(this.columns.keys())

    if (this.columns.size !== other.columns.size) {
      return false
    }
    if (!cols.every(column => other.columns.has(column))) {
      return false
    }

    if (this.data.length !== other.data.length) {
      return false
    }
    if (this.data.length === 0) {
      return true
    }

    const compare = (left, right) => {
      for (const k of cols) {
        if (left[k] &lt; right[k]) {
          return -1
        }
        if (left[k] > right[k]) {
          return 1
        }
      }
      return 0
    }
    const thisRows = this.data.slice().sort(compare)
    const otherRows = other.data.slice().sort(compare)
    return thisRows.every((row, i) => cols.every(k => (thisRows[i][k] === otherRows[i][k])))
  }

  // ------------------------------------------------------------------------------
  // Table transformations invoked by blocks.
  // Rely on operation functions provided by blocks, which take a row and a row
  // number as parameters and return a value for further processing.
  // ------------------------------------------------------------------------------

  /**
   * Drop columns.
   * @param {string[]} columns The names of the columns to discard.
   * @returns A new dataframe.
   */
  drop (columns) {
    util.check(this.hasColumns(columns),
               `unknown column(s) [${columns}] in drop`)
    const keep = Array.from(this.columns).filter(c => (!columns.includes(c)))
    return this.select(keep)
  }

  /**
   * Filter rows, keeping those that pass a test.
   * @param {Expr.base} expr The expression object that tests rows.
   * @returns A new dataframe (possibly empty).
   */
  filter (expr) {
    util.check(expr instanceof Expr.base,
               `filter expression is not an expression object`)
    const newData = this.data.filter((row, i) => expr.run(row, i))
    const newColumns = this._makeColumns(newData, this.columns)
    return new DataFrame(newData, newColumns)
  }

  /**
   * Group by the values in a column, storing the result in a new grouping column.
   * @param {string[]} columns The columns that determine groups.
   * @returns A new dataframe.
   */
  groupBy (columns) {
    util.check(columns.length > 0,
                `empty column name(s) for grouping`)
    util.check(this.hasColumns(columns),
                `unknown column(s) ${columns} in groupBy`)
    util.check(columns.length === (new Set(columns)).size,
                `duplicate column(s) in [${columns}] in groupBy`)
    const seen = new Map()
    let nextGroupId = 1
    const groupedData = this.data.map((row, i) => {
      const thisGroupId = this._makeGroupId(seen, row, i, columns, nextGroupId)
      if (thisGroupId === nextGroupId) {
        nextGroupId += 1
      }
      const newRow = {...row}
      newRow[DataFrame.GROUPCOL] = thisGroupId
      return newRow
    })
    const newColumns = this._makeColumns(groupedData, this.columns,
                                         {add: [DataFrame.GROUPCOL]})
    return new DataFrame(groupedData, newColumns)
  }

  /**
   * Create a new column using values from existing columns.
   * @param {string} newName New column's name. (If column already exists, it is replaced.)
   * @param {Expr.base} expr The expression object that calculates new values.
   * @returns A new dataframe.
   */
  mutate (newName, expr) {
    util.check(newName,
               `empty new column name for mutate`)
    util.check(newName.match(DataFrame.COLUMN_NAME),
               `illegal new name for column`)
    util.check(expr instanceof Expr.base,
               `new value expression is not an expression object`)
    const newData = this.data.map((row, i) => {
      const newRow = {...row}
      newRow[newName] = expr.run(row, i)
      return newRow
    })
    const newColumns = this._makeColumns(newData, this.columns,
                                         {add: [newName]})
    return new DataFrame(newData, newColumns)
  }

  /**
   * Select columns.
   * @param {string[]} columns The names of the columns to keep.
   * @returns A new dataframe.
   */
  select (columns) {
    util.check(this.hasColumns(columns),
               `unknown column(s) [${columns}] in select`)
    // Dropping all columns.
    if (columns.length === 0) {
      return new DataFrame([])
    }
    // Keeping some columns.
    const newData = this.data.map((row, i) => {
      const result = {}
      columns.forEach(key => {
        result[key] = row[key]
      })
      return result
    })
    return new DataFrame(newData, columns)
  }

  /**
   * Sort data by values in specified columns.
   * @param {string[]} columns Names of columns to sort by.
   * @param {Boolean} reverse Sort in reverse (descending) order?
   * @returns New data frame with sorted data.
   */
  sort (columns, reverse = false) {
    util.check(columns.length > 0,
                `no columns specified for sort`)
    util.check(this.hasColumns(columns),
                `unknown column(s) [${columns}] in sort`)
    const result = [...this.data]
    result.sort((left, right) => {
      return columns.reduce((soFar, col) => {
        if (soFar !== 0) {
          return soFar
        }
        if (left[col] === MISSING) {
          return -1
        }
        if (right[col] === MISSING) {
          return 1
        }
        if (left[col] &lt; right[col]) {
          return -1
        }
        if (left[col] > right[col]) {
          return 1
        }
        return 0
      }, 0)
    })
    if (reverse) {
      result.reverse()
    }
    return new DataFrame(result, this.columns)
  }

  /**
   * Summarize values (possibly grouped).
   * @param {Summarizer} op What to do.
   * @returns A new dataframe.
   */
  summarize (op) {
    util.check(op instanceof Summarize.base,
               `Operation must be summarizer object`)
    util.check(this.hasColumns([op.column]),
               `unknown column in summarize`)
    const newData = this.data.map(row => { return {...row} })
    const destCol = `${op.column}_${op.name}`
    this._summarizeColumn(newData, op, destCol)
    return new DataFrame(newData, [destCol])
  }

  /**
   * Remove grouping if present.
   * @returns A new dataframe.
   */
  ungroup () {
    util.check(this.hasColumns([DataFrame.GROUPCOL]),
                `cannot ungroup data that is not grouped`)
    const newData = this.data.map(row => {
      row = {...row}
      delete row[DataFrame.GROUPCOL]
      return row
    })
    const newColumns = this._makeColumns(newData, this.columns,
                                         {remove: [DataFrame.GROUPCOL]})
    return new DataFrame(newData, newColumns)
  }

  /**
   * Select rows with unique values in columns.
   * @param {string[]} columns The names of the columns to use for uniqueness test.
   * @returns A new dataframe.
   */
  unique (columns) {
    util.check(columns.length > 0,
                `no columns specified for select`)
    util.check(this.hasColumns(columns),
                `unknown column(s) [${columns}] in select`)
    const seen = new Map()
    const newData = []
    this.data.forEach((row, i) => this._findUnique(seen, newData, row, i, columns))
    return new DataFrame(newData, columns)
  }

  // ------------------------------------------------------------------------------
  // Methods that combine dataframes.
  // ------------------------------------------------------------------------------

  /**
   * Join this dataframe with another on equality between values in specified columns.
   * @param {string} thisName Name to use for this table in result.
   * @param {string} thisCol Name of column in this table.
   * @param {string} other Other table to join to.
   * @param {string} otherName Name to use for other table in result.
   * @param {string} otherCol Name of column in other table.
   * @returns A new dataframe.
   */
  join (thisName, thisCol, other, otherName, otherCol) {
    util.check(thisName.match(DataFrame.TABLE_NAME),
               `cannot use ${thisName} as table name`)
    util.check(this.hasColumns([thisCol]),
               `this does not have column ${thisCol}`)
    util.check(other instanceof DataFrame,
               `other table must be a dataframe`)
    util.check(otherName.match(DataFrame.TABLE_NAME),
               `cannot use ${otherName} as table name`)
    util.check(other.hasColumns([otherCol]),
               `other table does not have column ${otherCol}`)

    const result = []
    for (let thisRow of this.data) { 
      for (let otherRow of other.data) { 
        if (thisRow[thisCol] === otherRow[otherCol]) {
          const row = {}
          row[DataFrame.JOINCOL] = thisRow[thisCol]
          this._addFieldsExcept(row, thisRow, thisName, thisCol)
          this._addFieldsExcept(row, otherRow, otherName, otherCol)
          result.push(row)
        }
      }
    }

    const newColumns = [DataFrame.JOINCOL]
    this._addColumnsExcept(newColumns, thisName, this.columns, thisCol)
    this._addColumnsExcept(newColumns, otherName, other.columns, otherCol)

    return new DataFrame(result, newColumns)
  }

  // ------------------------------------------------------------------------------
  // Utility functions that are called from the outside (e.g., for testing or
  // to convert datatypes).
  // ------------------------------------------------------------------------------

  /**
   * Test whether the dataframe has the specified columns.
   * @param {string[]} names Names of column to check for.
   * @param {Boolean} exact Must column names match exactly?
   * @returns {Boolean} Are columns present?
   */
  hasColumns (names, exact = false) {
    util.check(Array.isArray(names),
               `require array of names`)
    if (exact &amp;&amp; (names.length != this.columns.size)) {
      return false
    }
    return names.every(n => (this.columns.has(n)))
  }

  // ------------------------------------------------------------------------------

  //
  // Add fields to object except the field being used as a join key.
  //
  _addFieldsExcept (result, row, tableName, exceptName) {
    Object.keys(row)
      .filter(key => (key !== exceptName))
      .forEach(key => { result[`${tableName}_${key}`] = row[key] })
  }

  //
  // Add columns to column list except the join column.
  //
  _addColumnsExcept (result, tableName, columns, exceptName) {
    Array.from(columns)
      .filter(col => (col !== exceptName))
      .forEach(col => result.push(`${tableName}_${col}`))
    return result
  }

  //
  // Check that columns are all consistent when constructing a new dataframe.
  //
  _checkData (values) {
    util.check(Array.isArray(values),
               `Values used to construct dataframe must be an array, not ${typeof values}`)
    if (values.length === 0) {
      return
    }
    const expected = new Set(Object.keys(values[0]))
    expected.forEach(name => {
      util.check(name.match(DataFrame.COLUMN_NAME) || DataFrame.SPECIAL_NAMES.has(name),
                 `Column name "${name}" not allowed`)
    })
    values.forEach((row, index) => {
      const keys = Object.keys(row)
      util.check(keys.length === expected.size,
                 `Row ${index} has wrong number of columns`)
      util.check(keys.every(k => expected.has(k)),
                 `Row ${index} has wrong column name(s)`)
    })
  }

  //
  // Find unique values across multiple columns.
  //
  _findUnique (seen, newData, row, i, columns) {
    const thisValue = row[columns[0]]
    const otherColumns = columns.slice(1)
    if (otherColumns.length === 0) {
      if (!seen.has(thisValue)) {
        seen.set(thisValue, true)
        newData.push(row)
      }
    }
    else {
      if (!seen.has(thisValue)) {
        seen.set(thisValue, new Map())
      }
      this._findUnique(seen.get(thisValue), newData, row, i, otherColumns)
    }
  }

  //
  // Create columns for new table from data, existing columns, and explict add/remove lists.
  //
  _makeColumns (data, oldColumns, extras = {}) {
    const result = new Set()

    // Trust the data if there is some.
    if (data.length > 0) {
      Object.keys(data[0]).forEach(key => result.add(key))
    }

    // Construct.
    else {
      if (oldColumns) {
        oldColumns.forEach(name => result.add(name))
      }
      if ('add' in extras) {
        extras.add.forEach(name => result.add(name))
      }
    }

    return result
  }

  //
  // Recurse down a list of column names to find or construct a group ID.
  //
  _makeGroupId (seen, row, i, columns, nextGroupId) {
    const thisValue = row[columns[0]]
    const otherColumns = columns.slice(1)
    if (seen.has(thisValue)) {
      if (otherColumns.length === 0) {
        return seen.get(thisValue)
      }
      else {
        const subMap = seen.get(thisValue)
        return this._makeGroupId(subMap, row, i, otherColumns, nextGroupId)
      }
    }
    else {
      if (otherColumns.length === 0) {
        seen.set(thisValue, nextGroupId)
        return nextGroupId
      }
      else {
        const subMap = new Map()
        seen.set(thisValue, subMap)
        return this._makeGroupId(subMap, row, i, otherColumns, nextGroupId)
      }
    }
  }

  //
  // Summarize a single column in place.
  //
  _summarizeColumn (data, op, destCol) {
    // Divide values into groups.
    const groups = new Map()
    data.forEach(row => {
      const groupId = (DataFrame.GROUPCOL in row) ? row[DataFrame.GROUPCOL] : null
      if (!groups.has(groupId)) {
        groups.set(groupId, [])
      }
      groups.get(groupId).push(row)
    })

    // Summarize each group.
    for (let groupId of groups.keys()) {
      const result = op.run(groups.get(groupId))
      groups.set(groupId, result)
    }

    // Paste back in each row.
    data.forEach(row => {
      const groupId = (DataFrame.GROUPCOL in row) ? row[DataFrame.GROUPCOL] : null
      row[destCol] = groups.get(groupId)
    })
  }
}

/**
 * Regular expression that table names have to match when joining.
 */
DataFrame.TABLE_NAME = /^[A-Za-z][A-Za-z0-9_]*$/

/**
 * Regular expression that column names must match
 */
DataFrame.COLUMN_NAME = /^[A-Za-z][A-Za-z0-9_]*$/

/**
 * Special column name used for grouping column.
 */
DataFrame.GROUPCOL = '_group_'

/**
 * Special column name used for join column.
 */
DataFrame.JOINCOL = '_join_'

/**
 * All special names (used for internal lookup).
 */
DataFrame.SPECIAL_NAMES = new Set([DataFrame.GROUPCOL, DataFrame.JOINCOL])

module.exports = {
  DataFrame
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BrowserInterface.html">BrowserInterface</a></li><li><a href="DataFrame.html">DataFrame</a></li><li><a href="Environment.html">Environment</a></li><li><a href="ExprAdd.html">ExprAdd</a></li><li><a href="ExprAnd.html">ExprAnd</a></li><li><a href="ExprArithmeticBase.html">ExprArithmeticBase</a></li><li><a href="ExprBase.html">ExprBase</a></li><li><a href="ExprBinary.html">ExprBinary</a></li><li><a href="ExprColumn.html">ExprColumn</a></li><li><a href="ExprCompareBase.html">ExprCompareBase</a></li><li><a href="ExprConvertBase.html">ExprConvertBase</a></li><li><a href="ExprDatetime.html">ExprDatetime</a></li><li><a href="ExprDatetimeBase.html">ExprDatetimeBase</a></li><li><a href="ExprDivide.html">ExprDivide</a></li><li><a href="ExprEqual.html">ExprEqual</a></li><li><a href="ExprGreater.html">ExprGreater</a></li><li><a href="ExprGreaterEqual.html">ExprGreaterEqual</a></li><li><a href="ExprIfElse.html">ExprIfElse</a></li><li><a href="ExprIsDatetime.html">ExprIsDatetime</a></li><li><a href="ExprIsLogical.html">ExprIsLogical</a></li><li><a href="ExprIsMissing.html">ExprIsMissing</a></li><li><a href="ExprIsNumber.html">ExprIsNumber</a></li><li><a href="ExprIsString.html">ExprIsString</a></li><li><a href="ExprLess.html">ExprLess</a></li><li><a href="ExprLessEqual.html">ExprLessEqual</a></li><li><a href="ExprLogical.html">ExprLogical</a></li><li><a href="ExprLogicalBase.html">ExprLogicalBase</a></li><li><a href="ExprMultiply.html">ExprMultiply</a></li><li><a href="ExprNegate.html">ExprNegate</a></li><li><a href="ExprNegationBase.html">ExprNegationBase</a></li><li><a href="ExprNot.html">ExprNot</a></li><li><a href="ExprNotEqual.html">ExprNotEqual</a></li><li><a href="ExprNullaryBase.html">ExprNullaryBase</a></li><li><a href="ExprNumber.html">ExprNumber</a></li><li><a href="ExprOr.html">ExprOr</a></li><li><a href="ExprPower.html">ExprPower</a></li><li><a href="ExprRemainder.html">ExprRemainder</a></li><li><a href="ExprString.html">ExprString</a></li><li><a href="ExprSubtract.html">ExprSubtract</a></li><li><a href="ExprTernaryBase.html">ExprTernaryBase</a></li><li><a href="ExprToDatetime.html">ExprToDatetime</a></li><li><a href="ExprToDay.html">ExprToDay</a></li><li><a href="ExprToHours.html">ExprToHours</a></li><li><a href="ExprToLogical.html">ExprToLogical</a></li><li><a href="ExprToMinutes.html">ExprToMinutes</a></li><li><a href="ExprToMonth.html">ExprToMonth</a></li><li><a href="ExprToNumber.html">ExprToNumber</a></li><li><a href="ExprToSeconds.html">ExprToSeconds</a></li><li><a href="ExprToString.html">ExprToString</a></li><li><a href="ExprToWeekday.html">ExprToWeekday</a></li><li><a href="ExprToYear.html">ExprToYear</a></li><li><a href="ExprTypecheckBase.html">ExprTypecheckBase</a></li><li><a href="ExprUnary.html">ExprUnary</a></li><li><a href="Pipeline.html">Pipeline</a></li><li><a href="Program.html">Program</a></li><li><a href="StageANOVA.html">StageANOVA</a></li><li><a href="StageBar.html">StageBar</a></li><li><a href="StageBase.html">StageBase</a></li><li><a href="StageBox.html">StageBox</a></li><li><a href="StageDot.html">StageDot</a></li><li><a href="StageDrop.html">StageDrop</a></li><li><a href="StageFilter.html">StageFilter</a></li><li><a href="StageGroupBy.html">StageGroupBy</a></li><li><a href="StageHistogram.html">StageHistogram</a></li><li><a href="StageJoin.html">StageJoin</a></li><li><a href="StageKolmogorovSmirnov.html">StageKolmogorovSmirnov</a></li><li><a href="StageKruskalWallis.html">StageKruskalWallis</a></li><li><a href="StageMutate.html">StageMutate</a></li><li><a href="StageNotify.html">StageNotify</a></li><li><a href="StagePlot.html">StagePlot</a></li><li><a href="StageRead.html">StageRead</a></li><li><a href="StageScatter.html">StageScatter</a></li><li><a href="StageSelect.html">StageSelect</a></li><li><a href="StageSort.html">StageSort</a></li><li><a href="StageStats.html">StageStats</a></li><li><a href="StageSummarize.html">StageSummarize</a></li><li><a href="StageTransform.html">StageTransform</a></li><li><a href="StageTTestOneSample.html">StageTTestOneSample</a></li><li><a href="StageTTestPaired.html">StageTTestPaired</a></li><li><a href="StageUngroup.html">StageUngroup</a></li><li><a href="StageUnique.html">StageUnique</a></li><li><a href="StageZTestOneSample.html">StageZTestOneSample</a></li><li><a href="Statistics.html">Statistics</a></li><li><a href="SummarizeBase.html">SummarizeBase</a></li><li><a href="SummarizeCount.html">SummarizeCount</a></li><li><a href="SummarizeMaximum.html">SummarizeMaximum</a></li><li><a href="SummarizeMean.html">SummarizeMean</a></li><li><a href="SummarizeMedian.html">SummarizeMedian</a></li><li><a href="SummarizeMinimum.html">SummarizeMinimum</a></li><li><a href="SummarizeStdDev.html">SummarizeStdDev</a></li><li><a href="SummarizeSum.html">SummarizeSum</a></li><li><a href="SummarizeVariance.html">SummarizeVariance</a></li><li><a href="UserInterface.html">UserInterface</a></li></ul><h3>Global</h3><ul><li><a href="global.html#check">check</a></li><li><a href="global.html#checkNumber">checkNumber</a></li><li><a href="global.html#checkTypeEqual">checkTypeEqual</a></li><li><a href="global.html#csvToTable">csvToTable</a></li><li><a href="global.html#equal">equal</a></li><li><a href="global.html#Expr">Expr</a></li><li><a href="global.html#fail">fail</a></li><li><a href="global.html#MISSING">MISSING</a></li><li><a href="global.html#Stage">Stage</a></li><li><a href="global.html#Summarize">Summarize</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
